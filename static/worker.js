(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["worker"],{

/***/ "./app/worker.js":
/*!***********************!*\
  !*** ./app/worker.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function () {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/eslint-loader/index.js?!./app/worker.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/eslint-loader/index.js?!./app/worker.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/eslint-loader??ref--7!./app/worker.js ***!\n  \\************************************************************/\n/*! no exports provided */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var raw_loader_target_wasm32_unknown_unknown_release_duplex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! raw-loader!!../../target/wasm32-unknown-unknown/release/duplex */ \"./node_modules/raw-loader/index.js!../target/wasm32-unknown-unknown/release/duplex.js\");\n/* harmony import */ var raw_loader_target_wasm32_unknown_unknown_release_duplex__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(raw_loader_target_wasm32_unknown_unknown_release_duplex__WEBPACK_IMPORTED_MODULE_0__);\n/* eslint-disable */\n\neval(raw_loader_target_wasm32_unknown_unknown_release_duplex__WEBPACK_IMPORTED_MODULE_0___default.a.replace(/\"duplex.wasm\"/g, '\"http://[::1]:8000/duplex.wasm\"'));\n/* eslint-enable */\n\nself.onmessage = ({ data: { cube } }) => {\n    Rust.duplex // eslint-disable-line\n        .then((obj) => {\n            self.postMessage({ cube: obj.display() });\n        })\n        .catch(console.error);\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/raw-loader/index.js!../target/wasm32-unknown-unknown/release/duplex.js\":\n/*!************************************************************************************!*\\\n  !*** ./node_modules/raw-loader!../target/wasm32-unknown-unknown/release/duplex.js ***!\n  \\************************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nmodule.exports = \"\\\"use strict\\\";\\n\\nfunction _typeof(obj) { if (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; }; } return _typeof(obj); }\\n\\nif (typeof Rust === \\\"undefined\\\") {\\n  var Rust = {};\\n}\\n\\n(function (root, factory) {\\n  if (typeof define === \\\"function\\\" && define.amd) {\\n    define([], factory);\\n  } else if ((typeof module === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(module)) === \\\"object\\\" && module.exports) {\\n    module.exports = factory();\\n  } else {\\n    Rust.duplex = factory();\\n  }\\n})(this, function () {\\n  return function (module_factory) {\\n    var instance = module_factory();\\n\\n    if (typeof window === \\\"undefined\\\" && (typeof process === \\\"undefined\\\" ? \\\"undefined\\\" : _typeof(process)) === \\\"object\\\") {\\n      var fs = require(\\\"fs\\\");\\n\\n      var path = require(\\\"path\\\");\\n\\n      var wasm_path = path.join(__dirname, \\\"duplex.wasm\\\");\\n      var buffer = fs.readFileSync(wasm_path);\\n      var mod = new WebAssembly.Module(buffer);\\n      var wasm_instance = new WebAssembly.Instance(mod, instance.imports);\\n      return instance.initialize(wasm_instance);\\n    } else {\\n      var file = fetch(\\\"duplex.wasm\\\", {\\n        credentials: \\\"same-origin\\\"\\n      });\\n      var wasm_instance = typeof WebAssembly.instantiateStreaming === \\\"function\\\" ? WebAssembly.instantiateStreaming(file, instance.imports).then(function (result) {\\n        return result.instance;\\n      }) : file.then(function (response) {\\n        return response.arrayBuffer();\\n      }).then(function (bytes) {\\n        return WebAssembly.compile(bytes);\\n      }).then(function (mod) {\\n        return WebAssembly.instantiate(mod, instance.imports);\\n      });\\n      return wasm_instance.then(function (wasm_instance) {\\n        var exports = instance.initialize(wasm_instance);\\n        console.log(\\\"Finished loading Rust wasm module 'duplex'\\\");\\n        return exports;\\n      }).catch(function (error) {\\n        console.log(\\\"Error loading Rust wasm module 'duplex':\\\", error);\\n        throw error;\\n      });\\n    }\\n  }(function () {\\n    var Module = {};\\n    Module.STDWEB_PRIVATE = {}; // This is based on code from Emscripten's preamble.js.\\n\\n    Module.STDWEB_PRIVATE.to_utf8 = function to_utf8(str, addr) {\\n      for (var i = 0; i < str.length; ++i) {\\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629\\n        var u = str.charCodeAt(i); // possibly a lead surrogate\\n\\n        if (u >= 0xD800 && u <= 0xDFFF) {\\n          u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\\n        }\\n\\n        if (u <= 0x7F) {\\n          HEAPU8[addr++] = u;\\n        } else if (u <= 0x7FF) {\\n          HEAPU8[addr++] = 0xC0 | u >> 6;\\n          HEAPU8[addr++] = 0x80 | u & 63;\\n        } else if (u <= 0xFFFF) {\\n          HEAPU8[addr++] = 0xE0 | u >> 12;\\n          HEAPU8[addr++] = 0x80 | u >> 6 & 63;\\n          HEAPU8[addr++] = 0x80 | u & 63;\\n        } else if (u <= 0x1FFFFF) {\\n          HEAPU8[addr++] = 0xF0 | u >> 18;\\n          HEAPU8[addr++] = 0x80 | u >> 12 & 63;\\n          HEAPU8[addr++] = 0x80 | u >> 6 & 63;\\n          HEAPU8[addr++] = 0x80 | u & 63;\\n        } else if (u <= 0x3FFFFFF) {\\n          HEAPU8[addr++] = 0xF8 | u >> 24;\\n          HEAPU8[addr++] = 0x80 | u >> 18 & 63;\\n          HEAPU8[addr++] = 0x80 | u >> 12 & 63;\\n          HEAPU8[addr++] = 0x80 | u >> 6 & 63;\\n          HEAPU8[addr++] = 0x80 | u & 63;\\n        } else {\\n          HEAPU8[addr++] = 0xFC | u >> 30;\\n          HEAPU8[addr++] = 0x80 | u >> 24 & 63;\\n          HEAPU8[addr++] = 0x80 | u >> 18 & 63;\\n          HEAPU8[addr++] = 0x80 | u >> 12 & 63;\\n          HEAPU8[addr++] = 0x80 | u >> 6 & 63;\\n          HEAPU8[addr++] = 0x80 | u & 63;\\n        }\\n      }\\n    };\\n\\n    Module.STDWEB_PRIVATE.noop = function () {};\\n\\n    Module.STDWEB_PRIVATE.to_js = function to_js(address) {\\n      var kind = HEAPU8[address + 12];\\n\\n      if (kind === 0) {\\n        return undefined;\\n      } else if (kind === 1) {\\n        return null;\\n      } else if (kind === 2) {\\n        return HEAP32[address / 4];\\n      } else if (kind === 3) {\\n        return HEAPF64[address / 8];\\n      } else if (kind === 4) {\\n        var pointer = HEAPU32[address / 4];\\n        var length = HEAPU32[(address + 4) / 4];\\n        return Module.STDWEB_PRIVATE.to_js_string(pointer, length);\\n      } else if (kind === 5) {\\n        return false;\\n      } else if (kind === 6) {\\n        return true;\\n      } else if (kind === 7) {\\n        var pointer = Module.STDWEB_PRIVATE.arena + HEAPU32[address / 4];\\n        var length = HEAPU32[(address + 4) / 4];\\n        var _output = [];\\n\\n        for (var i = 0; i < length; ++i) {\\n          _output.push(Module.STDWEB_PRIVATE.to_js(pointer + i * 16));\\n        }\\n\\n        return _output;\\n      } else if (kind === 8) {\\n        var arena = Module.STDWEB_PRIVATE.arena;\\n        var value_array_pointer = arena + HEAPU32[address / 4];\\n        var length = HEAPU32[(address + 4) / 4];\\n        var key_array_pointer = arena + HEAPU32[(address + 8) / 4];\\n        var _output = {};\\n\\n        for (var i = 0; i < length; ++i) {\\n          var key_pointer = HEAPU32[(key_array_pointer + i * 8) / 4];\\n          var key_length = HEAPU32[(key_array_pointer + 4 + i * 8) / 4];\\n          var key = Module.STDWEB_PRIVATE.to_js_string(key_pointer, key_length);\\n          var value = Module.STDWEB_PRIVATE.to_js(value_array_pointer + i * 16);\\n          _output[key] = value;\\n        }\\n\\n        return _output;\\n      } else if (kind === 9) {\\n        return Module.STDWEB_PRIVATE.acquire_js_reference(HEAP32[address / 4]);\\n      } else if (kind === 10 || kind === 12 || kind === 13) {\\n        var adapter_pointer = HEAPU32[address / 4];\\n        var pointer = HEAPU32[(address + 4) / 4];\\n        var deallocator_pointer = HEAPU32[(address + 8) / 4];\\n        var num_ongoing_calls = 0;\\n        var drop_queued = false;\\n\\n        var _output = function output() {\\n          if (pointer === 0 || drop_queued === true) {\\n            if (kind === 10) {\\n              throw new ReferenceError(\\\"Already dropped Rust function called!\\\");\\n            } else if (kind === 12) {\\n              throw new ReferenceError(\\\"Already dropped FnMut function called!\\\");\\n            } else {\\n              throw new ReferenceError(\\\"Already called or dropped FnOnce function called!\\\");\\n            }\\n          }\\n\\n          var function_pointer = pointer;\\n\\n          if (kind === 13) {\\n            _output.drop = Module.STDWEB_PRIVATE.noop;\\n            pointer = 0;\\n          }\\n\\n          if (num_ongoing_calls !== 0) {\\n            if (kind === 12 || kind === 13) {\\n              throw new ReferenceError(\\\"FnMut function called multiple times concurrently!\\\");\\n            }\\n          }\\n\\n          var args = Module.STDWEB_PRIVATE.alloc(16);\\n          Module.STDWEB_PRIVATE.serialize_array(args, arguments);\\n\\n          try {\\n            num_ongoing_calls += 1;\\n            Module.STDWEB_PRIVATE.dyncall(\\\"vii\\\", adapter_pointer, [function_pointer, args]);\\n            var result = Module.STDWEB_PRIVATE.tmp;\\n            Module.STDWEB_PRIVATE.tmp = null;\\n          } finally {\\n            num_ongoing_calls -= 1;\\n          }\\n\\n          if (drop_queued === true && num_ongoing_calls === 0) {\\n            _output.drop();\\n          }\\n\\n          return result;\\n        };\\n\\n        _output.drop = function () {\\n          if (num_ongoing_calls !== 0) {\\n            drop_queued = true;\\n            return;\\n          }\\n\\n          _output.drop = Module.STDWEB_PRIVATE.noop;\\n          var function_pointer = pointer;\\n          pointer = 0;\\n\\n          if (function_pointer != 0) {\\n            Module.STDWEB_PRIVATE.dyncall(\\\"vi\\\", deallocator_pointer, [function_pointer]);\\n          }\\n        };\\n\\n        return _output;\\n      } else if (kind === 14) {\\n        var pointer = HEAPU32[address / 4];\\n        var length = HEAPU32[(address + 4) / 4];\\n        var array_kind = HEAPU32[(address + 8) / 4];\\n        var pointer_end = pointer + length;\\n\\n        switch (array_kind) {\\n          case 0:\\n            return HEAPU8.subarray(pointer, pointer_end);\\n\\n          case 1:\\n            return HEAP8.subarray(pointer, pointer_end);\\n\\n          case 2:\\n            return HEAPU16.subarray(pointer, pointer_end);\\n\\n          case 3:\\n            return HEAP16.subarray(pointer, pointer_end);\\n\\n          case 4:\\n            return HEAPU32.subarray(pointer, pointer_end);\\n\\n          case 5:\\n            return HEAP32.subarray(pointer, pointer_end);\\n\\n          case 6:\\n            return HEAPF32.subarray(pointer, pointer_end);\\n\\n          case 7:\\n            return HEAPF64.subarray(pointer, pointer_end);\\n        }\\n      } else if (kind === 15) {\\n        return Module.STDWEB_PRIVATE.get_raw_value(HEAPU32[address / 4]);\\n      }\\n    };\\n\\n    Module.STDWEB_PRIVATE.serialize_object = function serialize_object(address, value) {\\n      var keys = Object.keys(value);\\n      var length = keys.length;\\n      var key_array_pointer = Module.STDWEB_PRIVATE.alloc(length * 8);\\n      var value_array_pointer = Module.STDWEB_PRIVATE.alloc(length * 16);\\n      HEAPU8[address + 12] = 8;\\n      HEAPU32[address / 4] = value_array_pointer;\\n      HEAPU32[(address + 4) / 4] = length;\\n      HEAPU32[(address + 8) / 4] = key_array_pointer;\\n\\n      for (var i = 0; i < length; ++i) {\\n        var key = keys[i];\\n        var key_length = Module.STDWEB_PRIVATE.utf8_len(key);\\n        var key_pointer = Module.STDWEB_PRIVATE.alloc(key_length);\\n        Module.STDWEB_PRIVATE.to_utf8(key, key_pointer);\\n        var key_address = key_array_pointer + i * 8;\\n        HEAPU32[key_address / 4] = key_pointer;\\n        HEAPU32[(key_address + 4) / 4] = key_length;\\n        Module.STDWEB_PRIVATE.from_js(value_array_pointer + i * 16, value[key]);\\n      }\\n    };\\n\\n    Module.STDWEB_PRIVATE.serialize_array = function serialize_array(address, value) {\\n      var length = value.length;\\n      var pointer = Module.STDWEB_PRIVATE.alloc(length * 16);\\n      HEAPU8[address + 12] = 7;\\n      HEAPU32[address / 4] = pointer;\\n      HEAPU32[(address + 4) / 4] = length;\\n\\n      for (var i = 0; i < length; ++i) {\\n        Module.STDWEB_PRIVATE.from_js(pointer + i * 16, value[i]);\\n      }\\n    };\\n\\n    Module.STDWEB_PRIVATE.from_js = function from_js(address, value) {\\n      var kind = Object.prototype.toString.call(value);\\n\\n      if (kind === \\\"[object String]\\\") {\\n        var length = Module.STDWEB_PRIVATE.utf8_len(value);\\n        var pointer = 0;\\n\\n        if (length > 0) {\\n          pointer = Module.STDWEB_PRIVATE.alloc(length);\\n          Module.STDWEB_PRIVATE.to_utf8(value, pointer);\\n        }\\n\\n        HEAPU8[address + 12] = 4;\\n        HEAPU32[address / 4] = pointer;\\n        HEAPU32[(address + 4) / 4] = length;\\n      } else if (kind === \\\"[object Number]\\\") {\\n        if (value === (value | 0)) {\\n          HEAPU8[address + 12] = 2;\\n          HEAP32[address / 4] = value;\\n        } else {\\n          HEAPU8[address + 12] = 3;\\n          HEAPF64[address / 8] = value;\\n        }\\n      } else if (value === null) {\\n        HEAPU8[address + 12] = 1;\\n      } else if (value === undefined) {\\n        HEAPU8[address + 12] = 0;\\n      } else if (value === false) {\\n        HEAPU8[address + 12] = 5;\\n      } else if (value === true) {\\n        HEAPU8[address + 12] = 6;\\n      } else if (kind === \\\"[object Symbol]\\\") {\\n        var id = Module.STDWEB_PRIVATE.register_raw_value(value);\\n        HEAPU8[address + 12] = 15;\\n        HEAP32[address / 4] = id;\\n      } else {\\n        var refid = Module.STDWEB_PRIVATE.acquire_rust_reference(value);\\n        HEAPU8[address + 12] = 9;\\n        HEAP32[address / 4] = refid;\\n      }\\n    }; // This is ported from Rust's stdlib; it's faster than\\n    // the string conversion from Emscripten.\\n\\n\\n    Module.STDWEB_PRIVATE.to_js_string = function to_js_string(index, length) {\\n      index = index | 0;\\n      length = length | 0;\\n      var end = (index | 0) + (length | 0);\\n      var output = \\\"\\\";\\n\\n      while (index < end) {\\n        var x = HEAPU8[index++];\\n\\n        if (x < 128) {\\n          output += String.fromCharCode(x);\\n          continue;\\n        }\\n\\n        var init = x & 0x7F >> 2;\\n        var y = 0;\\n\\n        if (index < end) {\\n          y = HEAPU8[index++];\\n        }\\n\\n        var ch = init << 6 | y & 63;\\n\\n        if (x >= 0xE0) {\\n          var z = 0;\\n\\n          if (index < end) {\\n            z = HEAPU8[index++];\\n          }\\n\\n          var y_z = (y & 63) << 6 | z & 63;\\n          ch = init << 12 | y_z;\\n\\n          if (x >= 0xF0) {\\n            var w = 0;\\n\\n            if (index < end) {\\n              w = HEAPU8[index++];\\n            }\\n\\n            ch = (init & 7) << 18 | (y_z << 6 | w & 63);\\n            output += String.fromCharCode(0xD7C0 + (ch >> 10));\\n            ch = 0xDC00 + (ch & 0x3FF);\\n          }\\n        }\\n\\n        output += String.fromCharCode(ch);\\n        continue;\\n      }\\n\\n      return output;\\n    };\\n\\n    Module.STDWEB_PRIVATE.id_to_ref_map = {};\\n    Module.STDWEB_PRIVATE.id_to_refcount_map = {};\\n    Module.STDWEB_PRIVATE.ref_to_id_map = new WeakMap(); // Not all types can be stored in a WeakMap\\n\\n    Module.STDWEB_PRIVATE.ref_to_id_map_fallback = new Map();\\n    Module.STDWEB_PRIVATE.last_refid = 1;\\n    Module.STDWEB_PRIVATE.id_to_raw_value_map = {};\\n    Module.STDWEB_PRIVATE.last_raw_value_id = 1;\\n\\n    Module.STDWEB_PRIVATE.acquire_rust_reference = function (reference) {\\n      if (reference === undefined || reference === null) {\\n        return 0;\\n      }\\n\\n      var id_to_refcount_map = Module.STDWEB_PRIVATE.id_to_refcount_map;\\n      var id_to_ref_map = Module.STDWEB_PRIVATE.id_to_ref_map;\\n      var ref_to_id_map = Module.STDWEB_PRIVATE.ref_to_id_map;\\n      var ref_to_id_map_fallback = Module.STDWEB_PRIVATE.ref_to_id_map_fallback;\\n      var refid = ref_to_id_map.get(reference);\\n\\n      if (refid === undefined) {\\n        refid = ref_to_id_map_fallback.get(reference);\\n      }\\n\\n      if (refid === undefined) {\\n        refid = Module.STDWEB_PRIVATE.last_refid++;\\n\\n        try {\\n          ref_to_id_map.set(reference, refid);\\n        } catch (e) {\\n          ref_to_id_map_fallback.set(reference, refid);\\n        }\\n      }\\n\\n      if (refid in id_to_ref_map) {\\n        id_to_refcount_map[refid]++;\\n      } else {\\n        id_to_ref_map[refid] = reference;\\n        id_to_refcount_map[refid] = 1;\\n      }\\n\\n      return refid;\\n    };\\n\\n    Module.STDWEB_PRIVATE.acquire_js_reference = function (refid) {\\n      return Module.STDWEB_PRIVATE.id_to_ref_map[refid];\\n    };\\n\\n    Module.STDWEB_PRIVATE.increment_refcount = function (refid) {\\n      Module.STDWEB_PRIVATE.id_to_refcount_map[refid]++;\\n    };\\n\\n    Module.STDWEB_PRIVATE.decrement_refcount = function (refid) {\\n      var id_to_refcount_map = Module.STDWEB_PRIVATE.id_to_refcount_map;\\n\\n      if (0 == --id_to_refcount_map[refid]) {\\n        var id_to_ref_map = Module.STDWEB_PRIVATE.id_to_ref_map;\\n        var ref_to_id_map_fallback = Module.STDWEB_PRIVATE.ref_to_id_map_fallback;\\n        var reference = id_to_ref_map[refid];\\n        delete id_to_ref_map[refid];\\n        delete id_to_refcount_map[refid];\\n        ref_to_id_map_fallback.delete(reference);\\n      }\\n    };\\n\\n    Module.STDWEB_PRIVATE.register_raw_value = function (value) {\\n      var id = Module.STDWEB_PRIVATE.last_raw_value_id++;\\n      Module.STDWEB_PRIVATE.id_to_raw_value_map[id] = value;\\n      return id;\\n    };\\n\\n    Module.STDWEB_PRIVATE.unregister_raw_value = function (id) {\\n      delete Module.STDWEB_PRIVATE.id_to_raw_value_map[id];\\n    };\\n\\n    Module.STDWEB_PRIVATE.get_raw_value = function (id) {\\n      return Module.STDWEB_PRIVATE.id_to_raw_value_map[id];\\n    };\\n\\n    Module.STDWEB_PRIVATE.alloc = function alloc(size) {\\n      return Module.web_malloc(size);\\n    };\\n\\n    Module.STDWEB_PRIVATE.dyncall = function (signature, ptr, args) {\\n      return Module.web_table.get(ptr).apply(null, args);\\n    }; // This is based on code from Emscripten's preamble.js.\\n\\n\\n    Module.STDWEB_PRIVATE.utf8_len = function utf8_len(str) {\\n      var len = 0;\\n\\n      for (var i = 0; i < str.length; ++i) {\\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.\\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\\n        var u = str.charCodeAt(i); // possibly a lead surrogate\\n\\n        if (u >= 0xD800 && u <= 0xDFFF) {\\n          u = 0x10000 + ((u & 0x3FF) << 10) | str.charCodeAt(++i) & 0x3FF;\\n        }\\n\\n        if (u <= 0x7F) {\\n          ++len;\\n        } else if (u <= 0x7FF) {\\n          len += 2;\\n        } else if (u <= 0xFFFF) {\\n          len += 3;\\n        } else if (u <= 0x1FFFFF) {\\n          len += 4;\\n        } else if (u <= 0x3FFFFFF) {\\n          len += 5;\\n        } else {\\n          len += 6;\\n        }\\n      }\\n\\n      return len;\\n    };\\n\\n    Module.STDWEB_PRIVATE.prepare_any_arg = function (value) {\\n      var arg = Module.STDWEB_PRIVATE.alloc(16);\\n      Module.STDWEB_PRIVATE.from_js(arg, value);\\n      return arg;\\n    };\\n\\n    Module.STDWEB_PRIVATE.acquire_tmp = function (dummy) {\\n      var value = Module.STDWEB_PRIVATE.tmp;\\n      Module.STDWEB_PRIVATE.tmp = null;\\n      return value;\\n    };\\n\\n    var HEAP8 = null;\\n    var HEAP16 = null;\\n    var HEAP32 = null;\\n    var HEAPU8 = null;\\n    var HEAPU16 = null;\\n    var HEAPU32 = null;\\n    var HEAPF32 = null;\\n    var HEAPF64 = null;\\n    Object.defineProperty(Module, 'exports', {\\n      value: {}\\n    });\\n\\n    function __web_on_grow() {\\n      var buffer = Module.instance.exports.memory.buffer;\\n      HEAP8 = new Int8Array(buffer);\\n      HEAP16 = new Int16Array(buffer);\\n      HEAP32 = new Int32Array(buffer);\\n      HEAPU8 = new Uint8Array(buffer);\\n      HEAPU16 = new Uint16Array(buffer);\\n      HEAPU32 = new Uint32Array(buffer);\\n      HEAPF32 = new Float32Array(buffer);\\n      HEAPF64 = new Float64Array(buffer);\\n    }\\n\\n    return {\\n      imports: {\\n        env: {\\n          \\\"__extjs_80d6d56760c65e49b7be8b6b01c1ea861b046bf0\\\": function __extjs_80d6d56760c65e49b7be8b6b01c1ea861b046bf0($0) {\\n            Module.STDWEB_PRIVATE.decrement_refcount($0);\\n          },\\n          \\\"__extjs_db0226ae1bbecd407e9880ee28ddc70fc3322d9c\\\": function __extjs_db0226ae1bbecd407e9880ee28ddc70fc3322d9c($0) {\\n            $0 = Module.STDWEB_PRIVATE.to_js($0);\\n            Module.STDWEB_PRIVATE.unregister_raw_value($0);\\n          },\\n          \\\"__extjs_ff5103e6cc179d13b4c7a785bdce2708fd559fc0\\\": function __extjs_ff5103e6cc179d13b4c7a785bdce2708fd559fc0($0) {\\n            Module.STDWEB_PRIVATE.tmp = Module.STDWEB_PRIVATE.to_js($0);\\n          },\\n          \\\"__web_on_grow\\\": __web_on_grow\\n        }\\n      },\\n      initialize: function initialize(instance) {\\n        Object.defineProperty(Module, 'instance', {\\n          value: instance\\n        });\\n        Object.defineProperty(Module, 'web_malloc', {\\n          value: Module.instance.exports.__web_malloc\\n        });\\n        Object.defineProperty(Module, 'web_free', {\\n          value: Module.instance.exports.__web_free\\n        });\\n        Object.defineProperty(Module, 'web_table', {\\n          value: Module.instance.exports.__web_table\\n        });\\n\\n        Module.exports.display = function display() {\\n          return Module.STDWEB_PRIVATE.acquire_tmp(Module.instance.exports.display());\\n        };\\n\\n        __web_on_grow();\\n\\n        Module.instance.exports.main();\\n        return Module.exports;\\n      }\\n    };\\n  });\\n});\"\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=8122d6304fc02e63bdc1.worker.js.map", null);
};

/***/ }),

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ })

}]);
//# sourceMappingURL=worker.js.map